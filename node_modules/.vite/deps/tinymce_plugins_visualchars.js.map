{
  "version": 3,
  "sources": ["../../tinymce/plugins/visualchars/plugin.js", "../../tinymce/plugins/visualchars/index.js"],
  "sourcesContent": ["/**\n * TinyMCE version 8.3.0 (2025-12-10)\n */\n\n(function () {\n    'use strict';\n\n    /* eslint-disable @typescript-eslint/no-wrapper-object-types */\n    const hasProto = (v, constructor, predicate) => {\n        if (predicate(v, constructor.prototype)) {\n            return true;\n        }\n        else {\n            // String-based fallback time\n            return v.constructor?.name === constructor.name;\n        }\n    };\n    const typeOf = (x) => {\n        const t = typeof x;\n        if (x === null) {\n            return 'null';\n        }\n        else if (t === 'object' && Array.isArray(x)) {\n            return 'array';\n        }\n        else if (t === 'object' && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) {\n            return 'string';\n        }\n        else {\n            return t;\n        }\n    };\n    const isType$1 = (type) => (value) => typeOf(value) === type;\n    const isSimpleType = (type) => (value) => typeof value === type;\n    const eq = (t) => (a) => t === a;\n    const isString = isType$1('string');\n    const isObject = isType$1('object');\n    const isNull = eq(null);\n    const isBoolean = isSimpleType('boolean');\n    const isNullable = (a) => a === null || a === undefined;\n    const isNonNullable = (a) => !isNullable(a);\n    const isFunction = isSimpleType('function');\n    const isNumber = isSimpleType('number');\n\n    /**\n     * The `Optional` type represents a value (of any type) that potentially does\n     * not exist. Any `Optional<T>` can either be a `Some<T>` (in which case the\n     * value does exist) or a `None` (in which case the value does not exist). This\n     * module defines a whole lot of FP-inspired utility functions for dealing with\n     * `Optional` objects.\n     *\n     * Comparison with null or undefined:\n     * - We don't get fancy null coalescing operators with `Optional`\n     * - We do get fancy helper functions with `Optional`\n     * - `Optional` support nesting, and allow for the type to still be nullable (or\n     * another `Optional`)\n     * - There is no option to turn off strict-optional-checks like there is for\n     * strict-null-checks\n     */\n    class Optional {\n        tag;\n        value;\n        // Sneaky optimisation: every instance of Optional.none is identical, so just\n        // reuse the same object\n        static singletonNone = new Optional(false);\n        // The internal representation has a `tag` and a `value`, but both are\n        // private: able to be console.logged, but not able to be accessed by code\n        constructor(tag, value) {\n            this.tag = tag;\n            this.value = value;\n        }\n        // --- Identities ---\n        /**\n         * Creates a new `Optional<T>` that **does** contain a value.\n         */\n        static some(value) {\n            return new Optional(true, value);\n        }\n        /**\n         * Create a new `Optional<T>` that **does not** contain a value. `T` can be\n         * any type because we don't actually have a `T`.\n         */\n        static none() {\n            return Optional.singletonNone;\n        }\n        /**\n         * Perform a transform on an `Optional` type. Regardless of whether this\n         * `Optional` contains a value or not, `fold` will return a value of type `U`.\n         * If this `Optional` does not contain a value, the `U` will be created by\n         * calling `onNone`. If this `Optional` does contain a value, the `U` will be\n         * created by calling `onSome`.\n         *\n         * For the FP enthusiasts in the room, this function:\n         * 1. Could be used to implement all of the functions below\n         * 2. Forms a catamorphism\n         */\n        fold(onNone, onSome) {\n            if (this.tag) {\n                return onSome(this.value);\n            }\n            else {\n                return onNone();\n            }\n        }\n        /**\n         * Determine if this `Optional` object contains a value.\n         */\n        isSome() {\n            return this.tag;\n        }\n        /**\n         * Determine if this `Optional` object **does not** contain a value.\n         */\n        isNone() {\n            return !this.tag;\n        }\n        // --- Functor (name stolen from Haskell / maths) ---\n        /**\n         * Perform a transform on an `Optional` object, **if** there is a value. If\n         * you provide a function to turn a T into a U, this is the function you use\n         * to turn an `Optional<T>` into an `Optional<U>`. If this **does** contain\n         * a value then the output will also contain a value (that value being the\n         * output of `mapper(this.value)`), and if this **does not** contain a value\n         * then neither will the output.\n         */\n        map(mapper) {\n            if (this.tag) {\n                return Optional.some(mapper(this.value));\n            }\n            else {\n                return Optional.none();\n            }\n        }\n        // --- Monad (name stolen from Haskell / maths) ---\n        /**\n         * Perform a transform on an `Optional` object, **if** there is a value.\n         * Unlike `map`, here the transform itself also returns an `Optional`.\n         */\n        bind(binder) {\n            if (this.tag) {\n                return binder(this.value);\n            }\n            else {\n                return Optional.none();\n            }\n        }\n        // --- Traversable (name stolen from Haskell / maths) ---\n        /**\n         * For a given predicate, this function finds out if there **exists** a value\n         * inside this `Optional` object that meets the predicate. In practice, this\n         * means that for `Optional`s that do not contain a value it returns false (as\n         * no predicate-meeting value exists).\n         */\n        exists(predicate) {\n            return this.tag && predicate(this.value);\n        }\n        /**\n         * For a given predicate, this function finds out if **all** the values inside\n         * this `Optional` object meet the predicate. In practice, this means that\n         * for `Optional`s that do not contain a value it returns true (as all 0\n         * objects do meet the predicate).\n         */\n        forall(predicate) {\n            return !this.tag || predicate(this.value);\n        }\n        filter(predicate) {\n            if (!this.tag || predicate(this.value)) {\n                return this;\n            }\n            else {\n                return Optional.none();\n            }\n        }\n        // --- Getters ---\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided `Optional` object does not contain a\n         * value.\n         */\n        getOr(replacement) {\n            return this.tag ? this.value : replacement;\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided `Optional` object does not contain a\n         * value.  Unlike `getOr`, in this method the `replacement` object is also\n         * `Optional` - meaning that this method will always return an `Optional`.\n         */\n        or(replacement) {\n            return this.tag ? this : replacement;\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided `Optional` object does not contain a\n         * value. Unlike `getOr`, in this method the `replacement` value is\n         * \"thunked\" - that is to say that you don't pass a value to `getOrThunk`, you\n         * pass a function which (if called) will **return** the `value` you want to\n         * use.\n         */\n        getOrThunk(thunk) {\n            return this.tag ? this.value : thunk();\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided Optional object does not contain a\n         * value.\n         *\n         * Unlike `or`, in this method the `replacement` value is \"thunked\" - that is\n         * to say that you don't pass a value to `orThunk`, you pass a function which\n         * (if called) will **return** the `value` you want to use.\n         *\n         * Unlike `getOrThunk`, in this method the `replacement` value is also\n         * `Optional`, meaning that this method will always return an `Optional`.\n         */\n        orThunk(thunk) {\n            return this.tag ? this : thunk();\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, throwing an\n         * exception if the provided `Optional` object does not contain a value.\n         *\n         * WARNING:\n         * You should only be using this function if you know that the `Optional`\n         * object **is not** empty (otherwise you're throwing exceptions in production\n         * code, which is bad).\n         *\n         * In tests this is more acceptable.\n         *\n         * Prefer other methods to this, such as `.each`.\n         */\n        getOrDie(message) {\n            if (!this.tag) {\n                throw new Error(message ?? 'Called getOrDie on None');\n            }\n            else {\n                return this.value;\n            }\n        }\n        // --- Interop with null and undefined ---\n        /**\n         * Creates an `Optional` value from a nullable (or undefined-able) input.\n         * Null, or undefined, is converted to `None`, and anything else is converted\n         * to `Some`.\n         */\n        static from(value) {\n            return isNonNullable(value) ? Optional.some(value) : Optional.none();\n        }\n        /**\n         * Converts an `Optional` to a nullable type, by getting the value if it\n         * exists, or returning `null` if it does not.\n         */\n        getOrNull() {\n            return this.tag ? this.value : null;\n        }\n        /**\n         * Converts an `Optional` to an undefined-able type, by getting the value if\n         * it exists, or returning `undefined` if it does not.\n         */\n        getOrUndefined() {\n            return this.value;\n        }\n        // --- Utilities ---\n        /**\n         * If the `Optional` contains a value, perform an action on that value.\n         * Unlike the rest of the methods on this type, `.each` has side-effects. If\n         * you want to transform an `Optional<T>` **into** something, then this is not\n         * the method for you. If you want to use an `Optional<T>` to **do**\n         * something, then this is the method for you - provided you're okay with not\n         * doing anything in the case where the `Optional` doesn't have a value inside\n         * it. If you're not sure whether your use-case fits into transforming\n         * **into** something or **doing** something, check whether it has a return\n         * value. If it does, you should be performing a transform.\n         */\n        each(worker) {\n            if (this.tag) {\n                worker(this.value);\n            }\n        }\n        /**\n         * Turn the `Optional` object into an array that contains all of the values\n         * stored inside the `Optional`. In practice, this means the output will have\n         * either 0 or 1 elements.\n         */\n        toArray() {\n            return this.tag ? [this.value] : [];\n        }\n        /**\n         * Turn the `Optional` object into a string for debugging or printing. Not\n         * recommended for production code, but good for debugging. Also note that\n         * these days an `Optional` object can be logged to the console directly, and\n         * its inner value (if it exists) will be visible.\n         */\n        toString() {\n            return this.tag ? `some(${this.value})` : 'none()';\n        }\n    }\n\n    const nativeSlice = Array.prototype.slice;\n    const map = (xs, f) => {\n        // pre-allocating array size when it's guaranteed to be known\n        // http://jsperf.com/push-allocated-vs-dynamic/22\n        const len = xs.length;\n        const r = new Array(len);\n        for (let i = 0; i < len; i++) {\n            const x = xs[i];\n            r[i] = f(x, i);\n        }\n        return r;\n    };\n    // Unwound implementing other functions in terms of each.\n    // The code size is roughly the same, and it should allow for better optimisation.\n    // const each = function<T, U>(xs: T[], f: (x: T, i?: number, xs?: T[]) => void): void {\n    const each$1 = (xs, f) => {\n        for (let i = 0, len = xs.length; i < len; i++) {\n            const x = xs[i];\n            f(x, i);\n        }\n    };\n    const filter = (xs, pred) => {\n        const r = [];\n        for (let i = 0, len = xs.length; i < len; i++) {\n            const x = xs[i];\n            if (pred(x, i)) {\n                r.push(x);\n            }\n        }\n        return r;\n    };\n    isFunction(Array.from) ? Array.from : (x) => nativeSlice.call(x);\n\n    // There are many variations of Object iteration that are faster than the 'for-in' style:\n    // http://jsperf.com/object-keys-iteration/107\n    //\n    // Use the native keys if it is available (IE9+), otherwise fall back to manually filtering\n    const keys = Object.keys;\n    const each = (obj, f) => {\n        const props = keys(obj);\n        for (let k = 0, len = props.length; k < len; k++) {\n            const i = props[k];\n            const x = obj[i];\n            f(x, i);\n        }\n    };\n\n    const Cell = (initial) => {\n        let value = initial;\n        const get = () => {\n            return value;\n        };\n        const set = (v) => {\n            value = v;\n        };\n        return {\n            get,\n            set\n        };\n    };\n\n    // Use window object as the global if it's available since CSP will block script evals\n    // eslint-disable-next-line @typescript-eslint/no-implied-eval\n    const Global = typeof window !== 'undefined' ? window : Function('return this;')();\n\n    /** path :: ([String], JsObj?) -> JsObj */\n    const path = (parts, scope) => {\n        let o = scope !== undefined && scope !== null ? scope : Global;\n        for (let i = 0; i < parts.length && o !== undefined && o !== null; ++i) {\n            o = o[parts[i]];\n        }\n        return o;\n    };\n    /** resolve :: (String, JsObj?) -> JsObj */\n    const resolve = (p, scope) => {\n        const parts = p.split('.');\n        return path(parts, scope);\n    };\n\n    // Run a function fn after rate ms. If another invocation occurs\n    // during the time it is waiting, ignore it completely.\n    const first = (fn, rate) => {\n        let timer = null;\n        const cancel = () => {\n            if (!isNull(timer)) {\n                clearTimeout(timer);\n                timer = null;\n            }\n        };\n        const throttle = (...args) => {\n            if (isNull(timer)) {\n                timer = setTimeout(() => {\n                    timer = null;\n                    fn.apply(null, args);\n                }, rate);\n            }\n        };\n        return {\n            cancel,\n            throttle\n        };\n    };\n\n    var global = tinymce.util.Tools.resolve('tinymce.PluginManager');\n\n    const get$2 = (toggleState) => {\n        const isEnabled = () => {\n            return toggleState.get();\n        };\n        return {\n            isEnabled\n        };\n    };\n\n    const fireVisualChars = (editor, state) => {\n        return editor.dispatch('VisualChars', { state });\n    };\n\n    const fromHtml = (html, scope) => {\n        const doc = scope || document;\n        const div = doc.createElement('div');\n        div.innerHTML = html;\n        if (!div.hasChildNodes() || div.childNodes.length > 1) {\n            const message = 'HTML does not have a single root node';\n            // eslint-disable-next-line no-console\n            console.error(message, html);\n            throw new Error(message);\n        }\n        return fromDom(div.childNodes[0]);\n    };\n    const fromTag = (tag, scope) => {\n        const doc = scope || document;\n        const node = doc.createElement(tag);\n        return fromDom(node);\n    };\n    const fromText = (text, scope) => {\n        const doc = scope || document;\n        const node = doc.createTextNode(text);\n        return fromDom(node);\n    };\n    const fromDom = (node) => {\n        // TODO: Consider removing this check, but left atm for safety\n        if (node === null || node === undefined) {\n            throw new Error('Node cannot be null or undefined');\n        }\n        return {\n            dom: node\n        };\n    };\n    const fromPoint = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom);\n    // tslint:disable-next-line:variable-name\n    const SugarElement = {\n        fromHtml,\n        fromTag,\n        fromText,\n        fromDom,\n        fromPoint\n    };\n\n    const ELEMENT = 1;\n    const TEXT = 3;\n\n    const unsafe = (name, scope) => {\n        return resolve(name, scope);\n    };\n    const getOrDie = (name, scope) => {\n        const actual = unsafe(name, scope);\n        if (actual === undefined || actual === null) {\n            throw new Error(name + ' not available on this browser');\n        }\n        return actual;\n    };\n\n    const getPrototypeOf = Object.getPrototypeOf;\n    /*\n     * IE9 and above\n     *\n     * MDN no use on this one, but here's the link anyway:\n     * https://developer.mozilla.org/en/docs/Web/API/HTMLElement\n     */\n    const sandHTMLElement = (scope) => {\n        return getOrDie('HTMLElement', scope);\n    };\n    const isPrototypeOf = (x) => {\n        // use Resolve to get the window object for x and just return undefined if it can't find it.\n        // undefined scope later triggers using the global window.\n        const scope = resolve('ownerDocument.defaultView', x);\n        // TINY-7374: We can't rely on looking at the owner window HTMLElement as the element may have\n        // been constructed in a different window and then appended to the current window document.\n        return isObject(x) && (sandHTMLElement(scope).prototype.isPrototypeOf(x) || /^HTML\\w*Element$/.test(getPrototypeOf(x).constructor.name));\n    };\n\n    const type = (element) => element.dom.nodeType;\n    const value = (element) => element.dom.nodeValue;\n    const isType = (t) => (element) => type(element) === t;\n    const isHTMLElement = (element) => isElement(element) && isPrototypeOf(element.dom);\n    const isElement = isType(ELEMENT);\n    const isText = isType(TEXT);\n\n    const rawSet = (dom, key, value) => {\n        /*\n         * JQuery coerced everything to a string, and silently did nothing on text node/null/undefined.\n         *\n         * We fail on those invalid cases, only allowing numbers and booleans.\n         */\n        if (isString(value) || isBoolean(value) || isNumber(value)) {\n            dom.setAttribute(key, value + '');\n        }\n        else {\n            // eslint-disable-next-line no-console\n            console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);\n            throw new Error('Attribute value was not simple');\n        }\n    };\n    const set = (element, key, value) => {\n        rawSet(element.dom, key, value);\n    };\n    const get$1 = (element, key) => {\n        const v = element.dom.getAttribute(key);\n        // undefined is the more appropriate value for JS, and this matches JQuery\n        return v === null ? undefined : v;\n    };\n    const remove$3 = (element, key) => {\n        element.dom.removeAttribute(key);\n    };\n\n    // Methods for handling attributes that contain a list of values <div foo=\"alpha beta theta\">\n    const read = (element, attr) => {\n        const value = get$1(element, attr);\n        return value === undefined || value === '' ? [] : value.split(' ');\n    };\n    const add$2 = (element, attr, id) => {\n        const old = read(element, attr);\n        const nu = old.concat([id]);\n        set(element, attr, nu.join(' '));\n        return true;\n    };\n    const remove$2 = (element, attr, id) => {\n        const nu = filter(read(element, attr), (v) => v !== id);\n        if (nu.length > 0) {\n            set(element, attr, nu.join(' '));\n        }\n        else {\n            remove$3(element, attr);\n        }\n        return false;\n    };\n\n    // IE11 Can return undefined for a classList on elements such as math, so we make sure it's not undefined before attempting to use it.\n    const supports = (element) => element.dom.classList !== undefined;\n    const get = (element) => read(element, 'class');\n    const add$1 = (element, clazz) => add$2(element, 'class', clazz);\n    const remove$1 = (element, clazz) => remove$2(element, 'class', clazz);\n\n    /*\n     * ClassList is IE10 minimum:\n     * https://developer.mozilla.org/en-US/docs/Web/API/Element.classList\n     *\n     * Note that IE doesn't support the second argument to toggle (at all).\n     * If it did, the toggler could be better.\n     */\n    const add = (element, clazz) => {\n        if (supports(element)) {\n            element.dom.classList.add(clazz);\n        }\n        else {\n            add$1(element, clazz);\n        }\n    };\n    const cleanClass = (element) => {\n        const classList = supports(element) ? element.dom.classList : get(element);\n        // classList is a \"live list\", so this is up to date already\n        if (classList.length === 0) {\n            // No more classes left, remove the class attribute as well\n            remove$3(element, 'class');\n        }\n    };\n    const remove = (element, clazz) => {\n        if (supports(element)) {\n            const classList = element.dom.classList;\n            classList.remove(clazz);\n        }\n        else {\n            remove$1(element, clazz);\n        }\n        cleanClass(element);\n    };\n\n    const getRaw = (element) => element.dom.contentEditable;\n\n    const charMap = {\n        '\\u00a0': 'nbsp',\n        '\\u00ad': 'shy'\n    };\n    const charMapToRegExp = (charMap, global) => {\n        let regExp = '';\n        each(charMap, (_value, key) => {\n            regExp += key;\n        });\n        return new RegExp('[' + regExp + ']', global ? 'g' : '');\n    };\n    const charMapToSelector = (charMap) => {\n        let selector = '';\n        each(charMap, (value) => {\n            if (selector) {\n                selector += ',';\n            }\n            selector += 'span.mce-' + value;\n        });\n        return selector;\n    };\n    const regExp = charMapToRegExp(charMap);\n    const regExpGlobal = charMapToRegExp(charMap, true);\n    const selector = charMapToSelector(charMap);\n    const nbspClass = 'mce-nbsp';\n\n    const wrapCharWithSpan = (value) => '<span data-mce-bogus=\"1\" class=\"mce-' + charMap[value] + '\">' + value + '</span>';\n\n    const isWrappedNbsp = (node) => node.nodeName.toLowerCase() === 'span' && node.classList.contains('mce-nbsp-wrap');\n    const isMatch = (n) => {\n        const value$1 = value(n);\n        return isText(n) &&\n            isString(value$1) &&\n            regExp.test(value$1);\n    };\n    const isContentEditableFalse = (node) => isHTMLElement(node) && getRaw(node) === 'false';\n    const isChildEditable = (node, currentState) => {\n        if (isHTMLElement(node) && !isWrappedNbsp(node.dom)) {\n            const value = getRaw(node);\n            if (value === 'true') {\n                return true;\n            }\n            else if (value === 'false') {\n                return false;\n            }\n        }\n        return currentState;\n    };\n    // inlined sugars PredicateFilter.descendants for file size but also make it only act on editable nodes it changes the current editable state when it traveses down\n    const filterEditableDescendants = (scope, predicate, editable) => {\n        let result = [];\n        const dom = scope.dom;\n        const children = map(dom.childNodes, SugarElement.fromDom);\n        const isEditable = (node) => isWrappedNbsp(node.dom) || !isContentEditableFalse(node);\n        each$1(children, (x) => {\n            if (editable && isEditable(x) && predicate(x)) {\n                result = result.concat([x]);\n            }\n            result = result.concat(filterEditableDescendants(x, predicate, isChildEditable(x, editable)));\n        });\n        return result;\n    };\n    const findParentElm = (elm, rootElm) => {\n        while (elm.parentNode) {\n            if (elm.parentNode === rootElm) {\n                return rootElm;\n            }\n            elm = elm.parentNode;\n        }\n        return undefined;\n    };\n    const replaceWithSpans = (text) => text.replace(regExpGlobal, wrapCharWithSpan);\n\n    const show = (editor, rootElm) => {\n        const dom = editor.dom;\n        const nodeList = filterEditableDescendants(SugarElement.fromDom(rootElm), isMatch, editor.dom.isEditable(rootElm));\n        each$1(nodeList, (n) => {\n            const parent = n.dom.parentNode;\n            if (isWrappedNbsp(parent)) {\n                add(SugarElement.fromDom(parent), nbspClass);\n            }\n            else {\n                const withSpans = replaceWithSpans(dom.encode(value(n) ?? ''));\n                const div = dom.create('div', {}, withSpans);\n                let node;\n                while ((node = div.lastChild)) {\n                    dom.insertAfter(node, n.dom);\n                }\n                editor.dom.remove(n.dom);\n            }\n        });\n    };\n    const hide = (editor, rootElm) => {\n        const nodeList = editor.dom.select(selector, rootElm);\n        each$1(nodeList, (node) => {\n            if (isWrappedNbsp(node)) {\n                remove(SugarElement.fromDom(node), nbspClass);\n            }\n            else {\n                editor.dom.remove(node, true);\n            }\n        });\n    };\n    const toggle = (editor) => {\n        const body = editor.getBody();\n        const bookmark = editor.selection.getBookmark();\n        let parentNode = findParentElm(editor.selection.getNode(), body);\n        // if user does select all the parentNode will be undefined\n        parentNode = parentNode !== undefined ? parentNode : body;\n        hide(editor, parentNode);\n        show(editor, parentNode);\n        editor.selection.moveToBookmark(bookmark);\n    };\n\n    const applyVisualChars = (editor, toggleState) => {\n        fireVisualChars(editor, toggleState.get());\n        const body = editor.getBody();\n        if (toggleState.get() === true) {\n            show(editor, body);\n        }\n        else {\n            hide(editor, body);\n        }\n    };\n    // Toggle state and save selection bookmark before applying visualChars\n    const toggleVisualChars = (editor, toggleState) => {\n        toggleState.set(!toggleState.get());\n        const bookmark = editor.selection.getBookmark();\n        applyVisualChars(editor, toggleState);\n        editor.selection.moveToBookmark(bookmark);\n    };\n\n    const register$2 = (editor, toggleState) => {\n        editor.addCommand('mceVisualChars', () => {\n            toggleVisualChars(editor, toggleState);\n        });\n    };\n\n    const option = (name) => (editor) => editor.options.get(name);\n    const register$1 = (editor) => {\n        const registerOption = editor.options.register;\n        registerOption('visualchars_default_state', {\n            processor: 'boolean',\n            default: false\n        });\n    };\n    const isEnabledByDefault = option('visualchars_default_state');\n\n    const setup$1 = (editor, toggleState) => {\n        /*\n          Note: applyVisualChars does not place a bookmark before modifying the DOM on init.\n          This will cause a loss of selection if the following conditions are met:\n            - Autofocus enabled, or editor is manually focused on init\n            - The first piece of text in the editor must be a nbsp\n            - Integrator has manually set the selection before init\n      \n          Another improvement would be to ensure DOM elements aren't destroyed/recreated,\n          but rather wrapped/unwrapped when applying styling for visualchars so that selection\n          is not lost.\n        */\n        editor.on('init', () => {\n            applyVisualChars(editor, toggleState);\n        });\n    };\n\n    const setup = (editor, toggleState) => {\n        const debouncedToggle = first(() => {\n            toggle(editor);\n        }, 300);\n        editor.on('keydown', (e) => {\n            if (toggleState.get() === true) {\n                e.keyCode === 13 ? toggle(editor) : debouncedToggle.throttle();\n            }\n        });\n        editor.on('remove', debouncedToggle.cancel);\n    };\n\n    const toggleActiveState = (editor, enabledStated) => (api) => {\n        api.setActive(enabledStated.get());\n        const editorEventCallback = (e) => api.setActive(e.state);\n        editor.on('VisualChars', editorEventCallback);\n        return () => editor.off('VisualChars', editorEventCallback);\n    };\n    const register = (editor, toggleState) => {\n        const onAction = () => editor.execCommand('mceVisualChars');\n        editor.ui.registry.addToggleButton('visualchars', {\n            tooltip: 'Show invisible characters',\n            icon: 'visualchars',\n            onAction,\n            onSetup: toggleActiveState(editor, toggleState),\n            context: 'any'\n        });\n        editor.ui.registry.addToggleMenuItem('visualchars', {\n            text: 'Show invisible characters',\n            icon: 'visualchars',\n            onAction,\n            onSetup: toggleActiveState(editor, toggleState),\n            context: 'any'\n        });\n    };\n\n    var Plugin = () => {\n        global.add('visualchars', (editor) => {\n            register$1(editor);\n            const toggleState = Cell(isEnabledByDefault(editor));\n            register$2(editor, toggleState);\n            register(editor, toggleState);\n            setup(editor, toggleState);\n            setup$1(editor, toggleState);\n            return get$2(toggleState);\n        });\n    };\n\n    Plugin();\n    /** *****\n     * DO NOT EXPORT ANYTHING\n     *\n     * IF YOU DO ROLLUP WILL LEAVE A GLOBAL ON THE PAGE\n     *******/\n\n})();\n", "// Exports the \"visualchars\" plugin for usage with module loaders\n// Usage:\n//   CommonJS:\n//     require('tinymce/plugins/visualchars')\n//   ES2015:\n//     import 'tinymce/plugins/visualchars'\nrequire('./plugin.js');"],
  "mappings": "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",
  "names": ["type", "value", "get", "set", "charMap", "global", "regExp", "selector"]
}
