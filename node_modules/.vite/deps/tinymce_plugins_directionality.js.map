{
  "version": 3,
  "sources": ["../../tinymce/plugins/directionality/plugin.js", "../../tinymce/plugins/directionality/index.js"],
  "sourcesContent": ["/**\n * TinyMCE version 8.3.0 (2025-12-10)\n */\n\n(function () {\n    'use strict';\n\n    var global = tinymce.util.Tools.resolve('tinymce.PluginManager');\n\n    /* eslint-disable @typescript-eslint/no-wrapper-object-types */\n    const hasProto = (v, constructor, predicate) => {\n        if (predicate(v, constructor.prototype)) {\n            return true;\n        }\n        else {\n            // String-based fallback time\n            return v.constructor?.name === constructor.name;\n        }\n    };\n    const typeOf = (x) => {\n        const t = typeof x;\n        if (x === null) {\n            return 'null';\n        }\n        else if (t === 'object' && Array.isArray(x)) {\n            return 'array';\n        }\n        else if (t === 'object' && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) {\n            return 'string';\n        }\n        else {\n            return t;\n        }\n    };\n    const isType$1 = (type) => (value) => typeOf(value) === type;\n    const isSimpleType = (type) => (value) => typeof value === type;\n    const isString = isType$1('string');\n    const isBoolean = isSimpleType('boolean');\n    const isNullable = (a) => a === null || a === undefined;\n    const isNonNullable = (a) => !isNullable(a);\n    const isFunction = isSimpleType('function');\n    const isNumber = isSimpleType('number');\n\n    /** Compose two unary functions. Similar to compose, but avoids using Function.prototype.apply. */\n    const compose1 = (fbc, fab) => (a) => fbc(fab(a));\n    const constant = (value) => {\n        return () => {\n            return value;\n        };\n    };\n    const never = constant(false);\n\n    /**\n     * The `Optional` type represents a value (of any type) that potentially does\n     * not exist. Any `Optional<T>` can either be a `Some<T>` (in which case the\n     * value does exist) or a `None` (in which case the value does not exist). This\n     * module defines a whole lot of FP-inspired utility functions for dealing with\n     * `Optional` objects.\n     *\n     * Comparison with null or undefined:\n     * - We don't get fancy null coalescing operators with `Optional`\n     * - We do get fancy helper functions with `Optional`\n     * - `Optional` support nesting, and allow for the type to still be nullable (or\n     * another `Optional`)\n     * - There is no option to turn off strict-optional-checks like there is for\n     * strict-null-checks\n     */\n    class Optional {\n        tag;\n        value;\n        // Sneaky optimisation: every instance of Optional.none is identical, so just\n        // reuse the same object\n        static singletonNone = new Optional(false);\n        // The internal representation has a `tag` and a `value`, but both are\n        // private: able to be console.logged, but not able to be accessed by code\n        constructor(tag, value) {\n            this.tag = tag;\n            this.value = value;\n        }\n        // --- Identities ---\n        /**\n         * Creates a new `Optional<T>` that **does** contain a value.\n         */\n        static some(value) {\n            return new Optional(true, value);\n        }\n        /**\n         * Create a new `Optional<T>` that **does not** contain a value. `T` can be\n         * any type because we don't actually have a `T`.\n         */\n        static none() {\n            return Optional.singletonNone;\n        }\n        /**\n         * Perform a transform on an `Optional` type. Regardless of whether this\n         * `Optional` contains a value or not, `fold` will return a value of type `U`.\n         * If this `Optional` does not contain a value, the `U` will be created by\n         * calling `onNone`. If this `Optional` does contain a value, the `U` will be\n         * created by calling `onSome`.\n         *\n         * For the FP enthusiasts in the room, this function:\n         * 1. Could be used to implement all of the functions below\n         * 2. Forms a catamorphism\n         */\n        fold(onNone, onSome) {\n            if (this.tag) {\n                return onSome(this.value);\n            }\n            else {\n                return onNone();\n            }\n        }\n        /**\n         * Determine if this `Optional` object contains a value.\n         */\n        isSome() {\n            return this.tag;\n        }\n        /**\n         * Determine if this `Optional` object **does not** contain a value.\n         */\n        isNone() {\n            return !this.tag;\n        }\n        // --- Functor (name stolen from Haskell / maths) ---\n        /**\n         * Perform a transform on an `Optional` object, **if** there is a value. If\n         * you provide a function to turn a T into a U, this is the function you use\n         * to turn an `Optional<T>` into an `Optional<U>`. If this **does** contain\n         * a value then the output will also contain a value (that value being the\n         * output of `mapper(this.value)`), and if this **does not** contain a value\n         * then neither will the output.\n         */\n        map(mapper) {\n            if (this.tag) {\n                return Optional.some(mapper(this.value));\n            }\n            else {\n                return Optional.none();\n            }\n        }\n        // --- Monad (name stolen from Haskell / maths) ---\n        /**\n         * Perform a transform on an `Optional` object, **if** there is a value.\n         * Unlike `map`, here the transform itself also returns an `Optional`.\n         */\n        bind(binder) {\n            if (this.tag) {\n                return binder(this.value);\n            }\n            else {\n                return Optional.none();\n            }\n        }\n        // --- Traversable (name stolen from Haskell / maths) ---\n        /**\n         * For a given predicate, this function finds out if there **exists** a value\n         * inside this `Optional` object that meets the predicate. In practice, this\n         * means that for `Optional`s that do not contain a value it returns false (as\n         * no predicate-meeting value exists).\n         */\n        exists(predicate) {\n            return this.tag && predicate(this.value);\n        }\n        /**\n         * For a given predicate, this function finds out if **all** the values inside\n         * this `Optional` object meet the predicate. In practice, this means that\n         * for `Optional`s that do not contain a value it returns true (as all 0\n         * objects do meet the predicate).\n         */\n        forall(predicate) {\n            return !this.tag || predicate(this.value);\n        }\n        filter(predicate) {\n            if (!this.tag || predicate(this.value)) {\n                return this;\n            }\n            else {\n                return Optional.none();\n            }\n        }\n        // --- Getters ---\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided `Optional` object does not contain a\n         * value.\n         */\n        getOr(replacement) {\n            return this.tag ? this.value : replacement;\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided `Optional` object does not contain a\n         * value.  Unlike `getOr`, in this method the `replacement` object is also\n         * `Optional` - meaning that this method will always return an `Optional`.\n         */\n        or(replacement) {\n            return this.tag ? this : replacement;\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided `Optional` object does not contain a\n         * value. Unlike `getOr`, in this method the `replacement` value is\n         * \"thunked\" - that is to say that you don't pass a value to `getOrThunk`, you\n         * pass a function which (if called) will **return** the `value` you want to\n         * use.\n         */\n        getOrThunk(thunk) {\n            return this.tag ? this.value : thunk();\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided Optional object does not contain a\n         * value.\n         *\n         * Unlike `or`, in this method the `replacement` value is \"thunked\" - that is\n         * to say that you don't pass a value to `orThunk`, you pass a function which\n         * (if called) will **return** the `value` you want to use.\n         *\n         * Unlike `getOrThunk`, in this method the `replacement` value is also\n         * `Optional`, meaning that this method will always return an `Optional`.\n         */\n        orThunk(thunk) {\n            return this.tag ? this : thunk();\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, throwing an\n         * exception if the provided `Optional` object does not contain a value.\n         *\n         * WARNING:\n         * You should only be using this function if you know that the `Optional`\n         * object **is not** empty (otherwise you're throwing exceptions in production\n         * code, which is bad).\n         *\n         * In tests this is more acceptable.\n         *\n         * Prefer other methods to this, such as `.each`.\n         */\n        getOrDie(message) {\n            if (!this.tag) {\n                throw new Error(message ?? 'Called getOrDie on None');\n            }\n            else {\n                return this.value;\n            }\n        }\n        // --- Interop with null and undefined ---\n        /**\n         * Creates an `Optional` value from a nullable (or undefined-able) input.\n         * Null, or undefined, is converted to `None`, and anything else is converted\n         * to `Some`.\n         */\n        static from(value) {\n            return isNonNullable(value) ? Optional.some(value) : Optional.none();\n        }\n        /**\n         * Converts an `Optional` to a nullable type, by getting the value if it\n         * exists, or returning `null` if it does not.\n         */\n        getOrNull() {\n            return this.tag ? this.value : null;\n        }\n        /**\n         * Converts an `Optional` to an undefined-able type, by getting the value if\n         * it exists, or returning `undefined` if it does not.\n         */\n        getOrUndefined() {\n            return this.value;\n        }\n        // --- Utilities ---\n        /**\n         * If the `Optional` contains a value, perform an action on that value.\n         * Unlike the rest of the methods on this type, `.each` has side-effects. If\n         * you want to transform an `Optional<T>` **into** something, then this is not\n         * the method for you. If you want to use an `Optional<T>` to **do**\n         * something, then this is the method for you - provided you're okay with not\n         * doing anything in the case where the `Optional` doesn't have a value inside\n         * it. If you're not sure whether your use-case fits into transforming\n         * **into** something or **doing** something, check whether it has a return\n         * value. If it does, you should be performing a transform.\n         */\n        each(worker) {\n            if (this.tag) {\n                worker(this.value);\n            }\n        }\n        /**\n         * Turn the `Optional` object into an array that contains all of the values\n         * stored inside the `Optional`. In practice, this means the output will have\n         * either 0 or 1 elements.\n         */\n        toArray() {\n            return this.tag ? [this.value] : [];\n        }\n        /**\n         * Turn the `Optional` object into a string for debugging or printing. Not\n         * recommended for production code, but good for debugging. Also note that\n         * these days an `Optional` object can be logged to the console directly, and\n         * its inner value (if it exists) will be visible.\n         */\n        toString() {\n            return this.tag ? `some(${this.value})` : 'none()';\n        }\n    }\n\n    const nativeSlice = Array.prototype.slice;\n    const map = (xs, f) => {\n        // pre-allocating array size when it's guaranteed to be known\n        // http://jsperf.com/push-allocated-vs-dynamic/22\n        const len = xs.length;\n        const r = new Array(len);\n        for (let i = 0; i < len; i++) {\n            const x = xs[i];\n            r[i] = f(x, i);\n        }\n        return r;\n    };\n    // Unwound implementing other functions in terms of each.\n    // The code size is roughly the same, and it should allow for better optimisation.\n    // const each = function<T, U>(xs: T[], f: (x: T, i?: number, xs?: T[]) => void): void {\n    const each = (xs, f) => {\n        for (let i = 0, len = xs.length; i < len; i++) {\n            const x = xs[i];\n            f(x, i);\n        }\n    };\n    const filter = (xs, pred) => {\n        const r = [];\n        for (let i = 0, len = xs.length; i < len; i++) {\n            const x = xs[i];\n            if (pred(x, i)) {\n                r.push(x);\n            }\n        }\n        return r;\n    };\n    isFunction(Array.from) ? Array.from : (x) => nativeSlice.call(x);\n\n    const fromHtml = (html, scope) => {\n        const doc = scope || document;\n        const div = doc.createElement('div');\n        div.innerHTML = html;\n        if (!div.hasChildNodes() || div.childNodes.length > 1) {\n            const message = 'HTML does not have a single root node';\n            // eslint-disable-next-line no-console\n            console.error(message, html);\n            throw new Error(message);\n        }\n        return fromDom(div.childNodes[0]);\n    };\n    const fromTag = (tag, scope) => {\n        const doc = scope || document;\n        const node = doc.createElement(tag);\n        return fromDom(node);\n    };\n    const fromText = (text, scope) => {\n        const doc = scope || document;\n        const node = doc.createTextNode(text);\n        return fromDom(node);\n    };\n    const fromDom = (node) => {\n        // TODO: Consider removing this check, but left atm for safety\n        if (node === null || node === undefined) {\n            throw new Error('Node cannot be null or undefined');\n        }\n        return {\n            dom: node\n        };\n    };\n    const fromPoint = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom);\n    // tslint:disable-next-line:variable-name\n    const SugarElement = {\n        fromHtml,\n        fromTag,\n        fromText,\n        fromDom,\n        fromPoint\n    };\n\n    const DOCUMENT_FRAGMENT = 11;\n    const ELEMENT = 1;\n    const TEXT = 3;\n\n    const is = (element, selector) => {\n        const dom = element.dom;\n        if (dom.nodeType !== ELEMENT) {\n            return false;\n        }\n        else {\n            const elem = dom;\n            if (elem.matches !== undefined) {\n                return elem.matches(selector);\n            }\n            else if (elem.msMatchesSelector !== undefined) {\n                return elem.msMatchesSelector(selector);\n            }\n            else if (elem.webkitMatchesSelector !== undefined) {\n                return elem.webkitMatchesSelector(selector);\n            }\n            else if (elem.mozMatchesSelector !== undefined) {\n                // cast to any as mozMatchesSelector doesn't exist in TS DOM lib\n                return elem.mozMatchesSelector(selector);\n            }\n            else {\n                throw new Error('Browser lacks native selectors');\n            } // unfortunately we can't throw this on startup :(\n        }\n    };\n\n    const name = (element) => {\n        const r = element.dom.nodeName;\n        return r.toLowerCase();\n    };\n    const type = (element) => element.dom.nodeType;\n    const isType = (t) => (element) => type(element) === t;\n    const isElement = isType(ELEMENT);\n    const isText = isType(TEXT);\n    const isDocumentFragment = isType(DOCUMENT_FRAGMENT);\n    const isTag = (tag) => (e) => isElement(e) && name(e) === tag;\n\n    const parent = (element) => Optional.from(element.dom.parentNode).map(SugarElement.fromDom);\n    const children$2 = (element) => map(element.dom.childNodes, SugarElement.fromDom);\n\n    /**\n     * Is the element a ShadowRoot?\n     *\n     * Note: this is insufficient to test if any element is a shadow root, but it is sufficient to differentiate between\n     * a Document and a ShadowRoot.\n     */\n    const isShadowRoot = (dos) => isDocumentFragment(dos) && isNonNullable(dos.dom.host);\n    const getRootNode = (e) => SugarElement.fromDom(e.dom.getRootNode());\n    /** If this element is in a ShadowRoot, return it. */\n    const getShadowRoot = (e) => {\n        const r = getRootNode(e);\n        return isShadowRoot(r) ? Optional.some(r) : Optional.none();\n    };\n    /** Return the host of a ShadowRoot.\n     *\n     * This function will throw if Shadow DOM is unsupported in the browser, or if the host is null.\n     * If you actually have a ShadowRoot, this shouldn't happen.\n     */\n    const getShadowHost = (e) => SugarElement.fromDom(e.dom.host);\n\n    const rawSet = (dom, key, value) => {\n        /*\n         * JQuery coerced everything to a string, and silently did nothing on text node/null/undefined.\n         *\n         * We fail on those invalid cases, only allowing numbers and booleans.\n         */\n        if (isString(value) || isBoolean(value) || isNumber(value)) {\n            dom.setAttribute(key, value + '');\n        }\n        else {\n            // eslint-disable-next-line no-console\n            console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);\n            throw new Error('Attribute value was not simple');\n        }\n    };\n    const set = (element, key, value) => {\n        rawSet(element.dom, key, value);\n    };\n    const remove = (element, key) => {\n        element.dom.removeAttribute(key);\n    };\n\n    // some elements, such as mathml, don't have style attributes\n    // others, such as angular elements, have style attributes that aren't a CSSStyleDeclaration\n    const isSupported = (dom) => dom.style !== undefined && isFunction(dom.style.getPropertyValue);\n\n    // Node.contains() is very, very, very good performance\n    // http://jsperf.com/closest-vs-contains/5\n    const inBody = (element) => {\n        // Technically this is only required on IE, where contains() returns false for text nodes.\n        // But it's cheap enough to run everywhere and Sugar doesn't have platform detection (yet).\n        const dom = isText(element) ? element.dom.parentNode : element.dom;\n        // use ownerDocument.body to ensure this works inside iframes.\n        // Normally contains is bad because an element \"contains\" itself, but here we want that.\n        if (dom === undefined || dom === null || dom.ownerDocument === null) {\n            return false;\n        }\n        const doc = dom.ownerDocument;\n        return getShadowRoot(SugarElement.fromDom(dom)).fold(() => doc.body.contains(dom), compose1(inBody, getShadowHost));\n    };\n\n    /*\n     * NOTE: For certain properties, this returns the \"used value\" which is subtly different to the \"computed value\" (despite calling getComputedStyle).\n     * Blame CSS 2.0.\n     *\n     * https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n     */\n    const get = (element, property) => {\n        const dom = element.dom;\n        /*\n         * IE9 and above per\n         * https://developer.mozilla.org/en/docs/Web/API/window.getComputedStyle\n         *\n         * Not in numerosity, because it doesn't memoize and looking this up dynamically in performance critical code would be horrendous.\n         *\n         * JQuery has some magic here for IE popups, but we don't really need that.\n         * It also uses element.ownerDocument.defaultView to handle iframes but that hasn't been required since FF 3.6.\n         */\n        const styles = window.getComputedStyle(dom);\n        const r = styles.getPropertyValue(property);\n        // jquery-ism: If r is an empty string, check that the element is not in a document. If it isn't, return the raw value.\n        // Turns out we do this a lot.\n        return (r === '' && !inBody(element)) ? getUnsafeProperty(dom, property) : r;\n    };\n    // removed: support for dom().style[property] where prop is camel case instead of normal property name\n    // empty string is what the browsers (IE11 and Chrome) return when the propertyValue doesn't exists.\n    const getUnsafeProperty = (dom, property) => isSupported(dom) ? dom.style.getPropertyValue(property) : '';\n\n    const getDirection = (element) => get(element, 'direction') === 'rtl' ? 'rtl' : 'ltr';\n\n    const ancestor$1 = (scope, predicate, isRoot) => {\n        let element = scope.dom;\n        const stop = isFunction(isRoot) ? isRoot : never;\n        while (element.parentNode) {\n            element = element.parentNode;\n            const el = SugarElement.fromDom(element);\n            if (predicate(el)) {\n                return Optional.some(el);\n            }\n            else if (stop(el)) {\n                break;\n            }\n        }\n        return Optional.none();\n    };\n\n    const ancestor = (scope, selector, isRoot) => ancestor$1(scope, (e) => is(e, selector), isRoot);\n\n    const children$1 = (scope, predicate) => filter(children$2(scope), predicate);\n\n    const children = (scope, selector) => \n    // It may surprise you to learn this is exactly what JQuery does\n    // TODO: Avoid all the wrapping and unwrapping\n    children$1(scope, (e) => is(e, selector));\n\n    const getParentElement = (element) => parent(element).filter(isElement);\n    // if the block is a list item, we need to get the parent of the list itself\n    const getNormalizedBlock = (element, isListItem) => {\n        const normalizedElement = isListItem ? ancestor(element, 'ol,ul') : Optional.some(element);\n        return normalizedElement.getOr(element);\n    };\n    const isListItem = isTag('li');\n    const setDirOnElements = (dom, blocks, dir) => {\n        each(blocks, (block) => {\n            const blockElement = SugarElement.fromDom(block);\n            const isBlockElementListItem = isListItem(blockElement);\n            const normalizedBlock = getNormalizedBlock(blockElement, isBlockElementListItem);\n            const normalizedBlockParent = getParentElement(normalizedBlock);\n            normalizedBlockParent.each((parent) => {\n                // TINY-9314: Remove any inline direction style to ensure that it is only set when necessary and that\n                // the dir attribute is favored\n                dom.setStyle(normalizedBlock.dom, 'direction', null);\n                const parentDirection = getDirection(parent);\n                if (parentDirection === dir) {\n                    remove(normalizedBlock, 'dir');\n                }\n                else {\n                    set(normalizedBlock, 'dir', dir);\n                }\n                // TINY-9314: Set an inline direction style if computed css direction is still not as desired. This can\n                // happen when the direction style is derived from a stylesheet.\n                if (getDirection(normalizedBlock) !== dir) {\n                    dom.setStyle(normalizedBlock.dom, 'direction', dir);\n                }\n                // Remove dir attr and direction style from list children\n                if (isBlockElementListItem) {\n                    const listItems = children(normalizedBlock, 'li[dir],li[style]');\n                    each(listItems, (listItem) => {\n                        remove(listItem, 'dir');\n                        dom.setStyle(listItem.dom, 'direction', null);\n                    });\n                }\n            });\n        });\n    };\n    const setDir = (editor, dir) => {\n        if (editor.selection.isEditable()) {\n            setDirOnElements(editor.dom, editor.selection.getSelectedBlocks(), dir);\n            editor.nodeChanged();\n        }\n    };\n\n    const register$1 = (editor) => {\n        editor.addCommand('mceDirectionLTR', () => {\n            setDir(editor, 'ltr');\n        });\n        editor.addCommand('mceDirectionRTL', () => {\n            setDir(editor, 'rtl');\n        });\n    };\n\n    const getNodeChangeHandler = (editor, dir) => (api) => {\n        const nodeChangeHandler = (e) => {\n            const element = SugarElement.fromDom(e.element);\n            api.setActive(getDirection(element) === dir);\n            api.setEnabled(editor.selection.isEditable());\n        };\n        editor.on('NodeChange', nodeChangeHandler);\n        api.setEnabled(editor.selection.isEditable());\n        return () => editor.off('NodeChange', nodeChangeHandler);\n    };\n    const register = (editor) => {\n        editor.ui.registry.addToggleButton('ltr', {\n            tooltip: 'Left to right',\n            icon: 'ltr',\n            onAction: () => editor.execCommand('mceDirectionLTR'),\n            onSetup: getNodeChangeHandler(editor, 'ltr')\n        });\n        editor.ui.registry.addToggleButton('rtl', {\n            tooltip: 'Right to left',\n            icon: 'rtl',\n            onAction: () => editor.execCommand('mceDirectionRTL'),\n            onSetup: getNodeChangeHandler(editor, 'rtl')\n        });\n    };\n\n    var Plugin = () => {\n        global.add('directionality', (editor) => {\n            register$1(editor);\n            register(editor);\n        });\n    };\n\n    Plugin();\n    /** *****\n     * DO NOT EXPORT ANYTHING\n     *\n     * IF YOU DO ROLLUP WILL LEAVE A GLOBAL ON THE PAGE\n     *******/\n\n})();\n", "// Exports the \"directionality\" plugin for usage with module loaders\n// Usage:\n//   CommonJS:\n//     require('tinymce/plugins/directionality')\n//   ES2015:\n//     import 'tinymce/plugins/directionality'\nrequire('./plugin.js');"],
  "mappings": "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",
  "names": ["type", "isListItem", "parent"]
}
